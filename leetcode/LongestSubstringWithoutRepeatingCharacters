class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet();
        int count = 0;
        int left = 0;

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            while (set.contains(c)) {
                set.remove(s.charAt(left));
                left++; 
            }
            set.add(c);
            count = Math.max(count, i - left + 1);
        }
        return count;
    }
}

// like, this method wouldn't work if letter is more than just alphabet.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0 || s.length() == 1) return s.length();
        if (s.contains(" ")) return ;
        boolean[] check = new boolean[26];
        int left = 0;
        int right = 0;
        int ans = 0;

        while (right < s.length()) {
            char c = s.charAt(right);
            while (check[c - 'a'] == true) {
                check[s.charAt(left) - 'a'] = false; // set it as false
                left++;
            }

            check[c - 'a'] = true; // set the value as true. then advance right

            ans = Math.max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
}

// sliding window using set:
// ojos!! i kept getting wrong because i was doing if (set.contains(c), insetad of while (set.contains(c)). be careuful, though!
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet();
        int left = 0;
        int right = 0;
        int ans = 0;
        while (right < s.length()) {
            char c = s.charAt(right);
            while (set.contains(c)) {
                set.remove(s.charAt(left));
                left++;
            }
            set.add(c);
            ans = Math.max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
}


// sep 3 (salesforce prep)
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int count = 0;
        if (s.length() == 0) return 0;

        int i = 0;
        Set set = new HashSet();

        for (int j = 0; j < s.length(); j++) {
            if (set.contains(s.charAt(j))) {
                while (s.charAt(i) != s.charAt(j)) {
                    set.remove(s.charAt(i));
                    i++;
                }
                set.remove(s.charAt(i));
                i++;
            }
            set.add(s.charAt(j));
            count = Math.max(count, set.size());
        }


        return count;
    }
}

// oct 6 - walc 
/* thought process (using sliding window & hashMap)
1. i and j pointer at the beginning. set hashmap for a~z with value 0.
s.charat(j) --> added to the hashmap.
j++
if value is greater than 1 (repeated), left++ & decrement until every value is valid.
2. currLength = j - i + 1
3. ans = Math.max(ans, currLength);
*/

class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) return 0;  
        int currLength = 0; // currLength 
        int ans = 0; // longest one.
        
        // character letter map (every letter starts with 0.)
        int[] map = new int[128];
        Arrays.fill(map, 0); 


        int i = 0; // left pointer
        for (int j = 0; j < s.length(); j++) {
            map[s.charAt(j)]++; // each element increment
            if (map[s.charAt(j)] > 1) { // it's an issue. left pointer should be adjusted.
                // until everything is decremented to proper value (> 1), loop through
                while (map[s.charAt(j)] > 1) {
                    map[s.charAt(i)]--;
                    i++;
                }
            }
            currLength = j - i + 1;
            ans = Math.max(ans, currLength);
        }
        return ans;
    }
}
